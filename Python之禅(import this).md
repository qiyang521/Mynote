#### Python之禅(import this)

优美胜于丑陋
明了胜于隐晦
简洁胜于复杂
复杂胜于混乱
扁平胜于嵌套
宽松胜于紧凑
可读性很重要
即便是特例，也不可违背这些规则
虽然现实往往不那么完美
但是不应该放过任何异常
除非你确定需要如此
如果存在多种可能，不要猜测
肯定有一种——通常也是唯一一种——最佳的解决方案
虽然这并不容易，因为你不是Python之父
动手比不动手要好
但不假思索就动手还不如不做
如果你的方案很难懂，那肯定不是一个好方案
如果你的方案很好懂，那肯定是一个好方案
命名空间非常有用，我们应当多加利用

​	1. **谈谈你对restful 规范的理解?****

​		以网络为基础的应用软件的架构设计,符合一组架构约束的条件和原则,RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束.

​	2. **Python解释器的种类及其特点:**

​		CPython:由C语言开发的 使用最广的解释器,在命名行下运行python，就是启动CPython解释器.'

​		IPython:基于cpython之上的一个交互式计时器 交互方式增强 功能和cpython一样.

​		PyPy:目标是执行效率 采用JIT技术 对python代码进行动态编译，提高执行效率.

​		JPython:运行在Java上的解释器 直接把python代码编译成Java字节码执行.

​		IronPython: 在微软 .NET 平台上的解释器，把python编译成. NET 的字节码.

​	3. **位和字节的关系:**

​		位:bit  一个二进制数据0或1,是计算机传输的最小单元,是计算机最小的数据单位,8位组成一个字节.

​		字节:byte  存储空间的计量单元,是计算机文件大小的基本计算单位,1个字节有8个bit.而1024个字节又代表1K.

​		一个英文占用一个字节(编码而定):1字母=1byte=8bit.

​		一个汉字占用两个字节(编码而定):1汉字=2byte=16位.

​		标点符号(中英文):中文占用两个字节,英文占用一个字节.

​	4. **PEP8规范.**

​		1.缩进:(1)代码块分割:Python使用一个冒号和缩进，来分割代码块，代码块指的是类的定义、函数的定义、流			程控制中if、for、while模块。缩进表示一个代码块的开始，非缩进表示一个代码的结束，相同的缩进表示			代码块中处于相同的级别.每一级缩进使用一个tab键(4个空格),两个代码块建议空一行.(2)换行:有时候写一			行代码，特别特别长的时候，就需要换行。文档建议续行与其包裹元素对齐，譬如用括号来垂直对齐

​		2.命名约定:变量名可以是字母、数字、下划线的组合，不能以数字开头，也不可以用关键字来命名.

​		3.(1)Python 里面区分大小写，类名一般使用首字母大写. (2)慎用字母I（i的大写）、l（L的小写）、o、O，			因为可能被人错看成数字1和0；(3)命名应既简短又具有描述性。例如，student_name比s_n好; (4)在运算			符前后各保留一个空格，例如 n == 1；

​	*5.* **ascii、unicode、utf-8、gbk 区别:**

​		ascii:美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语		言，共定义了128个字符 .

​		unicode:统一码（又称万国码），它为每种语言中的每个字符设定了唯一的二进制编码，以满足跨语言、跨		平台进行文本转换、处理的要求.

​		utf-8:是针对Unicode的一种可变长度字符编码，包含全世界所有国家需要用到的字符，且与ASCII相容。因		此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码.

​		gbk:即汉字编码字符集，主要针对汉字编码而形成的解决方案.

 6. **字节码和机器码的区别?**

    字节码: 是一种中间状态(中间码)的二进制代码(文件),需要直译器转译后才能成为机器码.

    机器码: 是计算机可以直接执行,并且执行速度最快的代码.

	7. **Python2和Python3的区别**

    	1. python2和Python3解释器编码不同,Python2使用ASCII编码,Python3使用的是utf-8编码.

    	2. 输入输出格式不同,Python2: print '内容'; Python3:print('内容'),Python2输入格式:raw_input(),python3输入格式:input()

    	3. Python 2 中 xrange() 创建迭代对象,在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）

    	4. 不等运算符: Python2.x 中不等于有两种写法!=和<>;Python3.x中去掉<>,只有!=这一种.

    	5. 数据类型: (1) Python3去除了long类型,只有一种整型---int. (2) 新增了bytes类型,对应于2.X版本的八位串.

        (3) dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧

    	6. 异常: 在 Python 3 中我们现在使用 as 作为关键词。 捕获异常的语法由 except exc, var 改为 except exc as var.

    	7. Python3 中，`3/2 == 1.5`；Python2 中，`3/2 == 1` 

8. **编码是一个什么样的过程？**

   编码是二进制到字符的过程.

9.  **Python 中的 GIL 是什么？全称?**

   GIL 全称 Global Interpreter Lock（全局解释器锁），任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。要避免这种“现象”利用操作系统的多核优势可以有下面几种方法：

   (1). 使用 C 语言编写扩展，创建原生线程，摆脱 GIL，但是即使是扩展，在 Python 代码内，任意一条Python 代码还是会有 GIL 限制.

   (2). 使用多进程代替多线程，使用多进程时，每个进程都有自己的 GIL。故不存在进程与进程之间的 GIL 限制。但是多进程不能共享内存。

10. **深拷贝和浅拷贝**

    浅拷贝操作只会拷贝被拷贝的第一层对象,对于更深层级的只不过拷贝其引用,相比于两个对象中的第二层,实际上浅拷贝之后,这两个还是一个对象,并不是独立的两个对象.深拷贝会拷贝被拷贝对象所有层级的对象,深拷贝之后便独立为两个对象,也就是一个真正意义上的拷贝.



11. **Flask 的 Route 是怎么实现的？* 你认为 Flask 框架有什么优缺点？**

    (1). 实际上在 Flask 类里面,route可以简单理解为不过是把对应的路由规则作为键，装饰的视图函数作为值，存到 `werkzeug.routing.Map` 对象（可以看成是和字典类似的数据结构）里.

    (2). Flask优点是轻量,灵活,可高度定制,插件化.缺点也是过于轻量，功能必须通过第三方插件实现，插件质量参差不齐，也不能完全保证后期维护。

12. **WSGI 是什么？uWSGI， nginx 这些都是什么用途？**
    1.  WSGI 就是一个通用的标准，遵守这个标准，我们能让我们的 Web 框架更加通用，编写更加简单。
    2. uwsgi 和 Nginx 都是 Web Server，不同的是 Nginx 负责 外网请求 ---(转换)--> 内网请求，uwsgi 负责的是 内网请求 -> Python Web 程序

13. **nginx 和 Apache 的区别？**

    1. nginx 相对 apache 的优点：

       (1). 轻量级，同样起web 服务，比apache 占用更少的内存及资源.

       (2). 高并发,nginx处理请求是异步非阻塞的,支持更多的并发连接,而apache是阻塞型的,在高并发下nginx能保持低资源低消耗高性能.

       (3). 配置简洁.

       (4). 高度模块化设计,编写模块相对简单.

       (5). 社区活跃.

    2. apache相对nginx的优点.

       (1). rewrite,比nginx的rewrite强大.

       (2). 模块超多,想到的都可以找到.

       (3). 少bug,nginx的bug相对较多.

       (4). 超稳定.

14. **数据库索引实现** (mysql面试指南:https://cloud.tencent.com/developer/article/1618515)

    1. 创建索引可以大大提高系统的性能

       (1). 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性.

       (2). 可以大大加快数据的检索速度，这也是创建索引的最主要的原因.

       (3). 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义.

       (4). 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间.

       (5). 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

    2. 增加索引也有许多不利的方面

       (1). 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加.

       (2). 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大.

       (3). 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度.

    3. 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引.

       (1). 在经常需要搜索的列上，可以加快搜索的速度；

       (2). 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；

       (3). 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；

       (4). 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；

       (5). 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；

       (6). 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度;

    4. 对于有些列不应该创建索引,一般来说，不应该创建索引的的这些列具有下列特点:

       (1). 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求.

       (2). 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度.

       (3). 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少.

       (4). 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引.

    5. 可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引.

       (1). 唯一索引: 唯一索引是不允许其中任何两行具有相同索引值的索引;当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓;

       (2). 主键索引: 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键;在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问;

       (3). 聚集索引: 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引;如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度;

15. **Python内存溢出和内存泄漏**

    

16. **Python垃圾回收机制**

    1. 垃圾回收机制(gc): Python解释器自带的一种机制,专门用来回收不可用的变量值所占用的内存空间.

    2. 引用计数: 变量值被变量名所关联的次数,变量值被多个变量引用,次数会增加,当引用的次数减少,最后变为0时,就被解释器的垃圾回收机制回收. 缺点:(1)效率低(2)可能会出现交叉引用(循环引用),会造成内存泄漏.

    3. 标记-清除: 标记-->遍历所有GC Roots对象(栈区所有内容或线程都可以作为GC Roots对象),然后将所有GC Roots对象可以直接或间接访问到的对象标记为存活对象,其余均为非存活对象,应该被清除.清除-->清除的过程将遍历堆中所有的对象,将没有标记的对象全部清除掉.

    4. 标记-清除:当应用程序可用的内存空间被耗尽时,就会停止整个程序,然后进行(1)标记(2)清除.

    5. 分代回收: 基于引用计数的回收机制,每次回收内存,都需要把所有对象的引用计数都遍历一遍,非常耗时,于是引用了分代回收来提高回收效率,分代回收采用以空间换时间的策略.

    6. 分代核心思想: 历经多次扫描的情况下,都没有被回收的变量,gc机制会认为,该变量是常用变量,gc对其扫描的频率就会降低.

    7. 分代实现原理: 分代指的是根据存活时间来为变量划分不同等级（也就是不同的代), 新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低

       回收: 依然是使用引用计数作为回收的依据

       缺点: 例如一个变量刚刚从新生代移入青春代，该变量的绑定关系就解除了，该变量应该被回收，但青春代的扫描频率低于新生代，所以该变量的回收就会被延迟。

17. **乐观锁和悲观锁**
    1. 悲观锁: 含义-->很悲观,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁.(1)具有强烈的独占和排他特性;(2)对数据外界(包括本系统当前的其他事务,以及来自外部系统的事务处理)修改持保守态度.因此,在整个数据处理过程中,将数据处于锁定态度.关系型数据库:行锁,表锁,读锁,写锁.
    2. 乐观锁: 含义-->(1)每次去拿数据的时候都认为别人不会修改,所以不会上锁,但在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号等机制.(2)使用场景:适用于多读的应用类型,这样可以提高吞吐量;(3)实现:(1)使用版本号;(2)发现冲突,上层应用不断的进行retry;
    3. 锁实现:往往依靠数据库提供的锁机制;(1)数据库层锁才真正保证数据访问的排他性;(2)应用层锁也无法保证外部系统会不会修改数据.

18. **SQL 和 NoSQL 区别?**

    1. 关系数据库(是指采用了关系模型来组织数据的数据库): 创建在关系模型基础上的数据库,借助于集合代数等数学概念和方法来处理数据库中的数据.现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示.

       *优点*: (1). 事务一致性:通过事务处理保持数据一致性;(2). 复杂查询:支持SQL,可以进行join等复杂查询.

       ​		  (3). 容易理解: 二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来			说更容易理解.

       ​		  (4). 使用方便: 通用的 SQL 语言使得操作关系型数据库非常方便.

       ​		  (5). 易于维护: 丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和			数据不一致的概率.

       *缺点*: (1). 读写性能: 在数据量达到一定规模时，由于关系型数据库的系统逻辑非常复杂，为了维护一致			性，使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重.

       ​		  (2). 表结构更新: 表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复			杂.

       ​		  (3). 高并发:网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来			说，硬盘I/O是一个很大的瓶颈.

       ​		  (4). 海量数据: 对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的.

    2. 非关系型数据库

       *介绍*: 是对不同于传统的关系数据库的数据库管理系统的统称,非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合. 分类: (1). 面向海量数据访问的面向文档数据库:这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为 MongoDB 以及 CouchDB (2). 面向高性能并发读写的 key-value 数据库: key-value数据库的主要特点即使具有极高的并发读写性能，Redis，Tokyo Cabinet，Flare 就是这类的代表;(3). 面向可扩展性的分布式数据库: 这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化.

       *优点*: (1) 读写性能: 无需经过 SQL 层的解析，读写性能很高。主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作；(2)简单的扩展: 基于键值对，数据没有耦合性，容易扩展。典型例子是 Cassandra，由于其架构是类似于经典的 P2P，所以能通过轻松地添加新的节点来扩展这个集群；(3)存储格式多: 支持key-value形式、文档形式、图片形式，而关系型数据库则只支持基础类型；(4)低廉的成本: 这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本；

       *缺点*: (1) 不提供对SQL的支持: 如果不支持 SQL 这样的工业标准，将会对用户产生一定的学习和应用迁移成本;(2) 支持的特性不够丰富: 现有产品所提供的功能都比较有限，大多数 NoSQL 数据库都不支持事务，也不像 MS SQL Server 和 Oracle 那样能提供各种附加功能，比如 BI 和报表等; (3) 现有的产品不够成熟:大多数产品都还处于初创期，和关系型数据库几十年的完善不可同日而语;

       *应用场景*:

       (1) 数据库表 schema 经常变化:比如在线商城，维护产品的属性经常要增加字段，这就意味着 ORMapping 层的代码和配置要改，如果该表的数据量过百万，新增字段会带来额外开销（重建索引等）

       (2) 数据库表字段是复杂数据类型:对于复杂数据类型，比如 SQL Sever 提供了可扩展性的支持，像 xml 类型的字段。DB 层对 xml 字段很难建高效索引，应用层又要做从字符流到 dom 的解析转换。NoSQL 以 json 方式存储，提供了原生态的支持，在效率方便远远高于传统关系型数据库.

       (3) 高并发数据库请求:此类应用常见于 web2.0 的网站，很多应用对于数据一致性要求很低，而关系型数据库的事务以及大表 JOIN 反而成了”性能杀手.

       (4) 海量数据的分布式存储: 海量数据的存储如果选用大型商用数据，如 Oracle，那么整个解决方案的成本是非常高的，要花很多钱在软硬件上。NoSQL 分布式存储，可以部署在廉价的硬件上，是一个性价比非常高的解决方案

       *NoSQL 和关系数据库结合*:

       一般把 NoSQL 和关系数据库进行结合使用，各取所长，需要使用关系特性的时候我们使用关系数据库，需要使用 NoSQL 特性的时候我们使用 NoSQL 数据库，各得其所.

19. **TCP连接三次握手和四次挥手**

    TCP是一种面向连接的,可靠的,基于字节流的传输层通信协议.

    ​	(1)三次握手: 客户端向服务端发送SYN连接,此时客户端进入SYN_SEND状态,服务端接收到客户端的请求后应答SYN+ACK,此时服务端进入SYN_RECV状态,客户端收到服务端应答ACK,此时客户端和服务器端都进入ESTABLISHED状态,完成TCP三次握手.

    ​	(2)四次挥手: 客户端发送FIN报文段,客户端进入FIN_WAIT_1状态,即告诉服务端没有数据需要传输了,请求关闭连接;服务器收到客户端FIN报文段后,向客户端应答一个ACK报文段,即应答客户端你的请求我收到了，但是我还没准备好，请等待我的关闭请求。客户端收到后进入FIN_WAIT_2状态；服务端完成数据传输后向客户端发送FIN报文段,请求关闭状态,服务器进入LAST_ACK状态;客户端收到服务端FIN报文段后,向服务端应答一个ACK报文段,然后客户端进入TIME_WAIT状态;服务端收到客户端ACK报文段后关闭连接,进入CLOSED状态,客户端此时关闭连接,进入CLOSED状态;

20. 































